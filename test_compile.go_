package config

import (
	"context"
	"testing"
	"time"
)

// TestCompilation ensures all features compile correctly
func TestCompilation(t *testing.T) {
	configJSON := `{"test": "value", "items": []}`
	schemaJSON := `{"type": "object"}`

	source, err := NewStrSource(configJSON, schemaJSON)
	if err != nil {
		t.Fatal(err)
	}

	manager, err := NewManager(source)
	if err != nil {
		t.Fatal(err)
	}

	// Test path caching
	_ = manager.Config()

	// Test change history
	manager.EnableHistory(true)
	_ = manager.GetHistory()
	manager.ClearHistory()

	// Test transactions
	err = manager.Batch(func(tx *Transaction) error {
		return tx.Replace("/test", "new_value")
	})
	if err != nil {
		t.Logf("Batch: %v", err)
	}

	// Test batch operations
	ops := []Operation{
		{Type: "replace", Path: "/test", Value: "batch_value"},
	}
	err = manager.BatchOperations(ops)
	if err != nil {
		t.Logf("BatchOperations: %v", err)
	}

	// Test query
	results, err := manager.Query("/test")
	if err != nil {
		t.Logf("Query: %v", err)
	}
	_ = results

	// Test FindAll
	_ = manager.FindAll(func(n *Node) bool {
		return n.Type() == String
	})

	// Test snapshots
	snapshot, err := manager.CreateSnapshot()
	if err != nil {
		t.Fatal(err)
	}

	err = manager.Restore(snapshot)
	if err != nil {
		t.Logf("Restore: %v", err)
	}

	// Test auto backup
	autoBackup := manager.StartAutoBackup(1*time.Second, 5)
	autoBackup.Stop()
	_ = autoBackup.GetSnapshots()
	_ = autoBackup.GetLatest()

	// Test validation service
	valService := NewValidationService("http://localhost:8080", 5*time.Second)
	valService.SetHeader("Auth", "token")
	manager.SetValidationService(valService)

	ctx := context.Background()
	_ = valService.Validate(ctx, map[string]interface{}{}, map[string]interface{}{})

	// Test custom validators
	manager.AddValidator("/test", ValidateRequired())
	manager.AddValidator("/test", ValidatePattern("*"))
	manager.AddValidator("/test", ValidateEnum("a", "b", "c"))
	manager.AddValidator("/test", ValidateRange(0, 100))

	// Test conflict detection
	version := manager.Version()
	_ = manager.ConditionalReplace("/test", version, "conflict_value")
	_ = manager.CompareAndSwap("/test", version, "cas_value")

	_ = manager.OptimisticUpdate("/test", func(current *Node) (interface{}, error) {
		return "updated", nil
	})

	detector := NewConflictDetector(manager)
	_ = detector.CheckVersion(version)

	_ = IsConflictError(nil)
	_, _ = GetConflictError(nil)

	t.Log("All features compile successfully")
}

// TestChangeHistory tests the change history functionality
func TestChangeHistory(t *testing.T) {
	history := NewChangeHistory(10)

	event := ChangeEvent{
		Timestamp: time.Now(),
		Operation: "test",
		Path:      "/test",
		Version:   1,
	}

	history.Add(event)

	all := history.GetAll()
	if len(all) != 1 {
		t.Errorf("Expected 1 event, got %d", len(all))
	}

	byPath := history.GetByPath("/test", 10)
	if len(byPath) != 1 {
		t.Errorf("Expected 1 event for path, got %d", len(byPath))
	}

	recent := history.GetRecent(5)
	if len(recent) != 1 {
		t.Errorf("Expected 1 recent event, got %d", len(recent))
	}

	history.Clear()
	if len(history.GetAll()) != 0 {
		t.Error("Expected empty history after clear")
	}
}

// TestQuerySegments tests query parsing
func TestQuerySegments(t *testing.T) {
	tests := []struct {
		query    string
		expected int
	}{
		{"/users/0/name", 3},
		{"/users/*/name", 3},
		{"/items/[*]", 2},
		{"/items/[0]", 2},
		{"/users/[?age>18]", 2},
	}

	for _, tt := range tests {
		segments, err := parseQuerySegments(tt.query)
		if err != nil {
			t.Errorf("Failed to parse %s: %v", tt.query, err)
			continue
		}
		if len(segments) != tt.expected {
			t.Errorf("Query %s: expected %d segments, got %d", tt.query, tt.expected, len(segments))
		}
	}
}

// TestConflictError tests conflict error functionality
func TestConflictError(t *testing.T) {
	err := NewConflictError("/test", "replace", 5, 10)

	if err.Path != "/test" {
		t.Errorf("Expected path /test, got %s", err.Path)
	}

	if !IsConflictError(err) {
		t.Error("Expected IsConflictError to return true")
	}

	conflict, ok := GetConflictError(err)
	if !ok {
		t.Error("Expected GetConflictError to return conflict")
	}
	if conflict.YourVersion != 5 {
		t.Errorf("Expected version 5, got %d", conflict.YourVersion)
	}
}